#! /usr/bin/env python3
# -*- coding: utf-8 -*-


import sys
import subprocess
from common import definitions
from tools import logger, emitter


def run_exploit(exploit_command, project_path, poc_path, output_file_path, hide_output=False):
    logger.trace(__name__ + ":" + sys._getframe().f_code.co_name, locals())
    exploit_command = str(exploit_command).replace('$POC', poc_path)
    exploit_command = "timeout 2m " + project_path + exploit_command + " > " + output_file_path + " 2>&1"
    # print(exploit_command)
    # Print executed command and execute it in console
    if not hide_output:
        emitter.normal("\t\t" + project_path)
        emitter.command(exploit_command)
    program_crashed = False
    process = subprocess.Popen([exploit_command], shell=True)
    output, error = process.communicate()
    program_output = ""
    return_code = ""
    with open(output_file_path, "r+") as output_file:
        program_output = output_file.readlines()
        if not hide_output:
            emitter.program_output(program_output)
        return_code = process.returncode
        program_output.append("RETURN CODE: " + str(return_code))
        output_file.writelines(program_output)

    if any(crash_word in str(program_output).lower() for crash_word in definitions.crash_word_list):
        program_crashed = True
        if not hide_output:
            emitter.normal("\t\tprogram crashed with exit code " + str(return_code) + "\n")
    else:
        if return_code != 0:
            if not hide_output:
                emitter.normal("\t\tprogram exited with exit code " + str(return_code) + "\n")
        else:
            if not hide_output:
                emitter.warning("\t\tProgram did not crash!!" + "\n")

    return return_code, program_crashed, program_output[:-1]
